import { Component, NgZone, OnInit } from '@angular/core';
import { HttpClient, HttpResponse } from '@angular/common/http';
import { Platform } from '@ionic/angular';
import { environment } from 'src/environments/environment';
import { FormControl, FormGroup } from '@angular/forms';
import { CapacitorCookies } from '@capacitor/core';

@Component({
  selector: 'app-tab2',
  templateUrl: 'tab2.page.html',
  styleUrls: ['tab2.page.scss']
})
export class Tab2Page implements OnInit {

  apiHost = environment.apiEndpoint;
  isLoading = false;
  uploadForm: FormGroup;
  formData = new FormData();
  responseData?: any;
  errorResponse?: any;

  constructor(private http: HttpClient, private platform: Platform, private zone: NgZone) {
    this.uploadForm = new FormGroup({
      email: new FormControl('email@email.com'),
      firstName: new FormControl('Hello'),
      lastName: new FormControl('World'),
      image: new FormControl<File|Blob|string|undefined>(undefined),
      jsonFile: new FormControl<File|Blob|string|undefined>(undefined)
    });
  }

  async ngOnInit(): Promise<void> {
    console.log('init', this.platform.is('cordova'), this.platform.is('capacitor'));
    this.formData = new FormData();
    // await this.callPost();
  }

  async onSubmit() {
    const url = `${environment.apiEndpoint}/upload`;
    console.log('submit for', url);
    this.isLoading = true;
    this.http.get(url, { withCredentials: true, observe:'response' }).subscribe(response => {
        console.log('get', response.headers, response.headers.getAll('Set-Token'));
        this.processGetResponse(response);
      }, e => {
        console.error(`error with GET ${url}:`, e);
      });
    console.log('submit');
    }

  async uploadChange(e: Event ) {
    const target = e.target as HTMLInputElement;
    const files = target.files as FileList;
    const file = files.item(0);
    console.log('uploadChange', e, file);
      try {
        // Here we build the JSON response then conver to Blob before setting it to FormData
        const jsonObject = this.uploadForm.getRawValue();
        console.log('starting json');
        const base64String = await this.toBase64(file);
        console.log('B64 img');
        jsonObject.image = base64String;
        const jsonBlob = this.buildJsonBlob(jsonObject);
        this.formData.set('jsonFile', jsonBlob);
        console.log('done json');

      } catch(error) {
        console.log('failed to convert to base64 string!', error);
      }
  }

  private async processGetResponse(getResponse: HttpResponse<any>) {
    console.log('processGetResponse');
    this.isLoading = true;
    this.formData.set('firstName', this.uploadForm.get('firstName')?.value);
    this.formData.set('lastName', this.uploadForm.get('lastName')?.value);
    this.formData.set('email', this.uploadForm.get('email')?.value);
    const cookieMap = await CapacitorCookies.getCookies();
    console.log('cookieMap', cookieMap);
    await CapacitorCookies.setCookie({
      key: 'key',
      value: 'helloworld',
    });
    this.http.post(`${environment.apiEndpoint}/upload`, this.formData).subscribe(response => {
        this.responseData = response;
      }, e => {
        console.log('error', e);
      this.errorResponse = e;
      }, () => this.isLoading = false);
  }

  private buildJsonBlob(o: any): Blob {
    const jsonString = JSON.stringify(o);
    const blob = new Blob([jsonString], {type: 'application/json'});
    const url  = URL.createObjectURL(blob);
    console.log('buildJson', o, url);
    return blob;
  }

  private toBase64(file: File | Blob): Promise<string> {
    console.log('toBase64', file);
    return new Promise((resolve, reject) => {
    // Be sure to use the patched FileReader generated by the code below!
    // There appear to be serialization issues that cause silent errors at the moment.
    const reader = new FileReader();
    reader.readAsDataURL(file);
    reader.onload = () => {
      console.log('reader resolved', reader.result);
      resolve(reader.result as string);
    };
    reader.onerror = (error) => {
      console.log('reader onerror', error);
      reject(error);
    };
});
  }

}
